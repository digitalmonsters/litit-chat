module.exports=[84596,e=>{"use strict";var t=e.i(68771),a=e.i(94747),o=e.i(36277),r=e.i(99929),n=e.i(27127),i=e.i(87757),s=e.i(19996),d=e.i(33610),c=e.i(89669),l=e.i(45794),u=e.i(57879),p=e.i(59391),m=e.i(38053),f=e.i(98285),h=e.i(53658),g=e.i(62110),v=e.i(93695);e.i(5745);var w=e.i(13799),y=e.i(15834),I=e.i(66030);e.i(20481);var E=e.i(39346),T=e.i(41005),R=e.i(72184);async function C(t){try{let o,r,n,i=await t.text();try{o=JSON.parse(i)}catch{return console.error("âŒ Failed to parse webhook payload"),y.NextResponse.json({ok:!0},{status:200})}let s=o.event||o.type||"unknown",d=o.payment||o.data?.payment,c=o.invoice||o.data?.invoice,l=o.subscription||o.data?.subscription;if("InvoicePaid"===s||"invoice.paid"===s||"Invoice.paid"===s){if(!c)return console.warn("âš ï¸ InvoicePaid webhook missing invoice data"),y.NextResponse.json({ok:!0},{status:200});return await A(c),y.NextResponse.json({ok:!0},{status:200})}if("InvoiceFailed"===s||"invoice.failed"===s||"Invoice.failed"===s){if(!c)return console.warn("âš ï¸ InvoiceFailed webhook missing invoice data"),y.NextResponse.json({ok:!0},{status:200});return await b(c),y.NextResponse.json({ok:!0},{status:200})}if("SubscriptionCancelled"===s||"subscription.cancelled"===s||"Subscription.cancelled"===s){if(!l)return console.warn("âš ï¸ SubscriptionCancelled webhook missing subscription data"),y.NextResponse.json({ok:!0},{status:200});return await N(l),y.NextResponse.json({ok:!0},{status:200})}if(!d)return console.warn("âš ï¸ Payment webhook missing payment data"),y.NextResponse.json({ok:!0},{status:200});console.log(`âœ… Received payment webhook: ${s} for payment: ${d.id}`);let u=(0,I.getFirestoreInstance)(),p=S(d.status),m=(0,E.collection)(u,I.COLLECTIONS.PAYMENTS),f=(0,E.query)(m,(0,E.where)("ghlTransactionId","==",d.id)),h=await (0,E.getDocs)(f);h.empty?(n={id:(r=(0,E.doc)(u,I.COLLECTIONS.PAYMENTS)).id,userId:"",amount:d.amount,currency:d.currency,status:p,paymentMethod:"ghl",ghlTransactionId:d.id,ghlContactId:d.contactId,description:`Payment from GHL: ${d.id}`,metadata:{ghlPaymentData:d},createdAt:(0,E.serverTimestamp)(),updatedAt:(0,E.serverTimestamp)()},"completed"===p&&(n.completedAt=(0,E.serverTimestamp)()),await (0,E.setDoc)(r,n),console.log(`âœ… Created payment record: ${r.id}`)):(r=h.docs[0].ref,n={status:p,amount:d.amount,currency:d.currency,updatedAt:(0,E.serverTimestamp)(),metadata:{...h.docs[0].data().metadata,ghlPaymentData:d}},"completed"===p?n.completedAt=(0,E.serverTimestamp)():"failed"===p&&(n.failedAt=(0,E.serverTimestamp)()),await (0,E.updateDoc)(r,n),console.log(`âœ… Updated payment: ${r.id}`));let g=(0,E.collection)(u,I.COLLECTIONS.USERS),v=(0,E.query)(g,(0,E.where)("ghlId","==",d.contactId)),w=await (0,E.getDocs)(v),C=(0,E.query)(g,(0,E.where)("ghlContactId","==",d.contactId)),$=await (0,E.getDocs)(C),k=[...w.docs,...$.docs],O=new Map;if(k.forEach(e=>O.set(e.id,e)),"completed"===p&&O.size>0){var a;let t=(a=d.amount)>=100?"enterprise":a>=50?"premium":a>=20?"basic":"free";for(let a of O.values()){let o=a.data(),n=a.id,i=o.tier||"free";(function(e,t){let a={free:0,basic:1,premium:2,enterprise:3,litplus:2},o=a[e||"free"]??0;return(a[t||"free"]??0)>o})(i,t)&&(await (0,E.updateDoc)(a.ref,{tier:t,updatedAt:(0,E.serverTimestamp)()}),!o.ghlId&&d.contactId&&await (0,E.updateDoc)(a.ref,{ghlId:d.contactId,ghlContactId:d.contactId,updatedAt:(0,E.serverTimestamp)()}),console.log(`âœ… Updated user tier: ${n} â†’ ${t}`));try{let t=await (0,E.getDoc)(r);if(t.exists()){let a=t.data();if(a.metadata?.autoConvertToStars!==!1&&d.amount>0){let e=await (0,T.convertUsdToStars)(n,d.amount);e.success&&console.log(`âœ… Converted ${d.amount} cents to ${e.starsAdded} stars for user: ${n}`)}if(a.messageId&&a.chatId){let{doc:t,updateDoc:o,serverTimestamp:r}=await e.A(22360),{getFirestoreInstance:n,COLLECTIONS:i}=await e.A(14595),s=n(),d=t(s,`${i.CHATS}/${a.chatId}/${i.MESSAGES}`,a.messageId);await o(d,{isLocked:!1,paymentId:a.id,updatedAt:r()})}}}catch(e){console.error(`âŒ Error processing wallet/conversion for user ${n}:`,e)}}if(1===O.size){let e=Array.from(O.keys())[0],t=await (0,E.getDoc)(r),a=t.exists()?t.data():null;if(await (0,E.updateDoc)(r,{userId:e,updatedAt:(0,E.serverTimestamp)()}),a?.metadata?.transactionId&&"completed"===p)try{await (0,R.completeTransaction)(a.metadata.transactionId,r.id,d.id),console.log(`âœ… Synced payment to transaction: ${a.metadata.transactionId}`)}catch(e){console.error(`âŒ Error syncing payment to transaction:`,e)}}}return"completed"===p&&0===O.size&&d.contactId&&console.log(`â„¹ï¸ Payment completed but no user found for contact: ${d.contactId}`),y.NextResponse.json({ok:!0},{status:200})}catch(e){return console.error("âŒ Error processing payment webhook:",e),y.NextResponse.json({ok:!0},{status:200})}}function S(e){return({pending:"pending",processing:"processing",completed:"completed",success:"completed",paid:"completed",failed:"failed",error:"failed",refunded:"refunded",cancelled:"cancelled",canceled:"cancelled"})[e?.toLowerCase()]||"pending"}async function A(e){let t=(0,I.getFirestoreInstance)();try{let a=(0,E.collection)(t,I.COLLECTIONS.PAYMENTS),o=(0,E.query)(a,(0,E.where)("ghlTransactionId","==",e.id)),r=await (0,E.getDocs)(o);if(r.empty)return void console.warn(`âš ï¸ InvoicePaid webhook: No payment record found for invoice: ${e.id}`);let n=r.docs[0],i=n.data();if(i.messageId&&i.chatId&&i.userId){let e=`${I.COLLECTIONS.CHATS}/${i.chatId}/${I.COLLECTIONS.MESSAGES}`,a=(0,E.doc)(t,e,i.messageId),o=await (0,E.getDoc)(a);if(o.exists()){let e,t=o.data();Array.isArray(t.unlockedBy)?(e={},t.unlockedBy.forEach(t=>{e[t]=(0,E.serverTimestamp)()})):e=t.unlockedBy||{},e[i.userId]?console.log(`â„¹ï¸ Message ${i.messageId} already unlocked by user ${i.userId}`):(e[i.userId]=(0,E.serverTimestamp)(),await (0,E.updateDoc)(a,{unlockedBy:e,updatedAt:(0,E.serverTimestamp)()}),console.log(`âœ… Payment received â€“ unlocked message ${i.messageId} for user ${i.userId}.`))}else console.warn(`âš ï¸ InvoicePaid webhook: Message not found: ${i.messageId}`)}let s=S(e.status);if(await (0,E.updateDoc)(n.ref,{status:s,amount:e.amount,currency:e.currency,updatedAt:(0,E.serverTimestamp)(),metadata:{...i.metadata,ghlInvoiceData:e}}),"completed"===s){if(await (0,E.updateDoc)(n.ref,{completedAt:(0,E.serverTimestamp)()}),i.metadata?.transactionId)try{await (0,R.completeTransaction)(i.metadata.transactionId,n.id,e.id),console.log(`âœ… Synced payment to transaction: ${i.metadata.transactionId}`)}catch(e){console.error(`âŒ Error syncing payment to transaction:`,e)}if(i.metadata?.type==="wallet_topup"&&i.userId){let t=i.metadata.stars;if(!t&&e.amount>0&&(t=e.amount*T.STAR_CONVERSION_RATE),t&&t>0){let a=await (0,T.addStars)(i.userId,t,`Wallet top-up via invoice ${e.id}`);a.success?console.log(`âœ… Top-up: ${t} stars added to wallet for user ${i.userId}`):console.error(`âŒ Error adding stars to wallet: ${a.error}`)}}if((i.metadata?.type==="subscription"||i.description?.toLowerCase().includes("subscription")||i.description?.toLowerCase().includes("litplus")||e.planName||e.interval)&&i.userId){let a=(0,E.doc)(t,I.COLLECTIONS.USERS,i.userId),o=await (0,E.getDoc)(a);if(o.exists()){let t=o.data();await (0,E.updateDoc)(a,{tier:"litplus",updatedAt:(0,E.serverTimestamp)(),metadata:{...t.metadata,subscriptionId:i.ghlTransactionId||e.id,subscriptionPlan:i.metadata?.plan||e.planName||"litplus",subscriptionStatus:"active",subscriptionStartedAt:(0,E.serverTimestamp)()}}),console.log(`âœ… Subscription activated: User ${i.userId} tier set to 'litplus'`)}}}console.log(`âœ… Updated payment: ${n.id} for invoice: ${e.id}`)}catch(t){throw console.error(`âŒ Error handling InvoicePaid event for invoice ${e.id}:`,t),t}}async function b(e){let t=(0,I.getFirestoreInstance)();try{let o=(0,E.collection)(t,I.COLLECTIONS.PAYMENTS),r=(0,E.query)(o,(0,E.where)("ghlTransactionId","==",e.id)),n=await (0,E.getDocs)(r),i=null,s=null;if(!n.empty){let t=n.docs[0],a=t.data();i=a.userId||null,await (0,E.updateDoc)(t.ref,{status:"failed",updatedAt:(0,E.serverTimestamp)(),failedAt:(0,E.serverTimestamp)(),metadata:{...a.metadata,ghlInvoiceData:e,failureReason:"Invoice payment failed"}}),console.log(`âŒ Payment failed for invoice: ${e.id} (payment: ${t.id})`)}if(!i&&e.contactId){let a=(0,E.collection)(t,I.COLLECTIONS.USERS),o=(0,E.query)(a,(0,E.where)("ghlId","==",e.contactId)),r=await (0,E.getDocs)(o);if(!r.empty){let e=r.docs[0];i=e.id,s=e.data().email??null}}if(i){let o=(0,E.doc)(t,I.COLLECTIONS.USERS,i),r=await (0,E.getDoc)(o);if(r.exists()){var a;let t,n,d=r.data();s=d.email??null;let c=(a=i,t=Date.now(),n=Math.random().toString(36).substring(2,15),`${a}-${t}-${n}`),l=`${process.env.NEXT_PUBLIC_APP_URL||"https://lit.it"}/reactivate?token=${c}`;await (0,E.updateDoc)(o,{tier:"free",updatedAt:(0,E.serverTimestamp)(),metadata:{...d.metadata,subscriptionStatus:"failed",subscriptionFailedAt:(0,E.serverTimestamp)(),reactivationToken:c,reactivationLink:l}}),console.log(`âœ… User ${i} tier set to 'free' due to failed payment`),await $(e.contactId,s,l),console.log(`âœ… Reactivation link sent for user ${i}`)}}else console.warn(`âš ï¸ InvoiceFailed: Could not find user for invoice ${e.id}`)}catch(t){throw console.error(`âŒ Error handling InvoiceFailed event for invoice ${e.id}:`,t),t}}async function $(t,a,o){try{if(t)try{let{sendMessage:a}=await e.A(85037),r=`Your subscription payment failed. Click here to reactivate: ${o}`;await a(t,r,void 0,"email"),console.log(`âœ… Reactivation link sent via GHL to contact ${t}`);return}catch(e){console.warn(`âš ï¸ Failed to send via GHL, trying email:`,e)}a&&console.log(`ðŸ“§ Reactivation link for ${a}: ${o}`)}catch(e){console.error("âŒ Error sending reactivation link:",e)}}async function N(e){let t=(0,I.getFirestoreInstance)();try{let a=(0,E.collection)(t,I.COLLECTIONS.PAYMENTS),o=(0,E.query)(a,(0,E.where)("ghlTransactionId","==",e.id)),r=await (0,E.getDocs)(o);if(r.empty){console.warn(`âš ï¸ SubscriptionCancelled webhook: No payment record found for subscription: ${e.id}`);let a=(0,E.collection)(t,I.COLLECTIONS.USERS),o=(0,E.query)(a,(0,E.where)("ghlId","==",e.contactId)),r=await (0,E.getDocs)(o);if(!r.empty){let e=r.docs[0],t=e.data();await (0,E.updateDoc)(e.ref,{tier:"free",updatedAt:(0,E.serverTimestamp)(),metadata:{...t.metadata,subscriptionStatus:"cancelled",subscriptionCancelledAt:(0,E.serverTimestamp)()}}),console.log(`âœ… User ${e.id} subscription cancelled, tier set to free`)}return}let n=r.docs[0],i=n.data();if(await (0,E.updateDoc)(n.ref,{status:"cancelled",updatedAt:(0,E.serverTimestamp)(),metadata:{...i.metadata,ghlSubscriptionData:e,subscriptionStatus:"cancelled"}}),i.metadata?.type==="subscription"&&i.userId){let e=(0,E.doc)(t,I.COLLECTIONS.USERS,i.userId),a=await (0,E.getDoc)(e);if(a.exists()){let t=a.data();await (0,E.updateDoc)(e,{tier:"free",updatedAt:(0,E.serverTimestamp)(),metadata:{...t.metadata,subscriptionStatus:"cancelled",subscriptionCancelledAt:(0,E.serverTimestamp)()}}),console.log(`âœ… User ${i.userId} subscription cancelled, tier set to free`)}}console.log(`âœ… Subscription cancelled: ${e.id} (payment: ${n.id})`)}catch(t){throw console.error(`âŒ Error handling SubscriptionCancelled event for subscription ${e.id}:`,t),t}}e.s(["POST",()=>C],52512);var k=e.i(52512);let O=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/payments/webhook/route",pathname:"/api/payments/webhook",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/litit-chat/app/api/payments/webhook/route.ts",nextConfigOutput:"standalone",userland:k}),{workAsyncStorage:x,workUnitAsyncStorage:D,serverHooks:P}=O;function L(){return(0,o.patchFetch)({workAsyncStorage:x,workUnitAsyncStorage:D})}async function U(e,t,o){O.isDev&&(0,r.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let y="/api/payments/webhook/route";y=y.replace(/\/index$/,"")||"/";let I=await O.prepare(e,t,{srcPage:y,multiZoneDraftMode:!1});if(!I)return t.statusCode=400,t.end("Bad Request"),null==o.waitUntil||o.waitUntil.call(o,Promise.resolve()),null;let{buildId:E,params:T,nextConfig:R,parsedUrl:C,isDraftMode:S,prerenderManifest:A,routerServerContext:b,isOnDemandRevalidate:$,revalidateOnlyGenerated:N,resolvedPathname:k,clientReferenceManifest:x,serverActionsManifest:D}=I,P=(0,d.normalizeAppPath)(y),L=!!(A.dynamicRoutes[P]||A.routes[k]),U=async()=>((null==b?void 0:b.render404)?await b.render404(e,t,C,!1):t.end("This page could not be found"),null);if(L&&!S){let e=!!A.routes[k],t=A.dynamicRoutes[P];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await U();throw new v.NoFallbackError}}let M=null;!L||O.isDev||S||(M="/index"===(M=k)?"/":M);let _=!0===O.isDev||!L,q=L&&!_;D&&x&&(0,i.setReferenceManifestsSingleton)({page:y,clientReferenceManifest:x,serverActionsManifest:D,serverModuleMap:(0,s.createServerModuleMap)({serverActionsManifest:D})});let H=e.method||"GET",F=(0,n.getTracer)(),j=F.getActiveScopeSpan(),B={params:T,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:_,incrementalCache:(0,r.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:o.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,o)=>O.onRequestError(e,t,o,b)},sharedContext:{buildId:E}},G=new c.NodeNextRequest(e),K=new c.NodeNextResponse(t),Y=l.NextRequestAdapter.fromNodeNextRequest(G,(0,l.signalFromNodeResponse)(t));try{let i=async e=>O.handle(Y,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=F.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let o=a.get("next.route");if(o){let t=`${H} ${o}`;e.setAttributes({"next.route":o,"http.route":o,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${y}`)}),s=!!(0,r.getRequestMeta)(e,"minimalMode"),d=async r=>{var n,d;let c=async({previousCacheEntry:a})=>{try{if(!s&&$&&N&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await i(r);e.fetchMetrics=B.renderOpts.fetchMetrics;let d=B.renderOpts.pendingWaitUntil;d&&o.waitUntil&&(o.waitUntil(d),d=void 0);let c=B.renderOpts.collectedTags;if(!L)return await (0,m.sendResponse)(G,K,n,B.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,f.toNodeOutgoingHttpHeaders)(n.headers);c&&(t[g.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=g.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,o=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=g.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:w.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:o}}}}catch(t){throw(null==a?void 0:a.isStale)&&await O.onRequestError(e,t,{routerKind:"App Router",routePath:y,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:q,isOnDemandRevalidate:$})},b),t}},l=await O.handleResponse({req:e,nextConfig:R,cacheKey:M,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:$,revalidateOnlyGenerated:N,responseGenerator:c,waitUntil:o.waitUntil,isMinimalMode:s});if(!L)return null;if((null==l||null==(n=l.value)?void 0:n.kind)!==w.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(d=l.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",$?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),S&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let u=(0,f.fromNodeOutgoingHttpHeaders)(l.value.headers);return s&&L||u.delete(g.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||t.getHeader("Cache-Control")||u.get("Cache-Control")||u.set("Cache-Control",(0,h.getCacheControlHeader)(l.cacheControl)),await (0,m.sendResponse)(G,K,new Response(l.value.body,{headers:u,status:l.value.status||200})),null};j?await d(j):await F.withPropagatedContext(e.headers,()=>F.trace(u.BaseServerSpan.handleRequest,{spanName:`${H} ${y}`,kind:n.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},d))}catch(t){if(t instanceof v.NoFallbackError||await O.onRequestError(e,t,{routerKind:"App Router",routePath:P,routeType:"route",revalidateReason:(0,p.getRevalidateReason)({isStaticGeneration:q,isOnDemandRevalidate:$})}),L)throw t;return await (0,m.sendResponse)(G,K,new Response(null,{status:500})),null}}e.s(["handler",()=>U,"patchFetch",()=>L,"routeModule",()=>O,"serverHooks",()=>P,"workAsyncStorage",()=>x,"workUnitAsyncStorage",()=>D],84596)}];

//# sourceMappingURL=a37d4_next_dist_esm_build_templates_app-route_ee8a7379.js.map